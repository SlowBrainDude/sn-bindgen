<html><head><title>SN bindgen: Semantics </title><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/styles/androidstudio.min.css" /><script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/highlight.min.js"></script><script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/languages/scala.min.js"></script><script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/languages/c.min.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="/assets/styles.css" /><link rel="stylesheet" href="/assets/template.css" /><script src="/assets/search.js"></script><script src="/assets/search-index.js"></script><link rel="stylesheet" href="/assets/subatomic-search.css" /><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /></head><body><div class="container"><header class="main-header"><div class="site-title"><h1><a href="/">SN bindgen</a></h1><small>Scala 3 Native binding generator to C libraries</small></div><div id="searchContainer" class="searchContainer"></div><div class="site-links"><a href="https://github.com/indoorvivants/sn-bindgen"><img src="https://cdn.svgporn.com/logos/github-icon.svg" class="gh-logo" /></a></div></header><div><a class="nav-btn" href="/index.html">Home</a><a class="nav-btn" href="/motivation/index.html">Motivation</a><a class="nav-btn" href="/configuration/index.html">Configuration </a><a class="nav-btn" href="/cookbook/index.html">Cookbook</a><a class="nav-btn" href="/limitations/index.html">Limitations</a><a class="nav-btn nav-selected" href="/semantics/index.html">Semantics </a><a class="nav-btn" href="/quickstart/index.html">Quick start</a></div><hr /><div><!--toc:start-->
<ul>
<li><a href="#structs-are-converted-to-opaque-types">Structs are converted to opaque types</a>
<ul>
<li><a href="#you-can-disable-constructor-generation">You can disable constructor generation</a></li>
</ul>
</li>
<li><a href="#unions-are-converted-to-opaque-types">Unions are converted to opaque types</a>
<ul>
<li><a href="#simple-functions-are-converted-to-direct-extern-functions">Simple functions are converted to direct <code>@extern</code> functions</a></li>
</ul>
</li>
<li><a href="#problematic-functions-generate-c-forwarders">Problematic functions generate C forwarders</a></li>
<li><a href="#enums-are-generated-for-specific-c-type">Enums are generated for specific C type</a></li>
<li><a href="#function-pointers-are-defined-as-opaque-types">Function pointers are defined as opaque types</a></li>
<li><a href="#recursive-structs-are-rewritten-with-opaque-pointers">Recursive structs are rewritten with opaque pointers</a></li>
<li><a href="#global-enums-are-rendered-as-constants">Global enums are rendered as constants</a></li>
</ul>
<!--toc:end-->
<h2><a href="#structs-are-converted-to-opaque-types" id="structs-are-converted-to-opaque-types">Structs are converted to opaque types</a></h2>
<p>For those types, we generate getters, setters, <code>Tag</code> definition, and two <code>apply</code> methods:</p>
<ol>
<li>A constructor, which takes all the parameters as arguments</li>
<li>An allocator, which only creates an instance on the heap, without initialising it</li>
</ol>
<div style = "display:flex;width:100%; font-size:16px; justify-content: space-between;"><div style = "width: 40%; text-align: left"><b>C file</b><pre><code class = "hljs language-c"><br />    typedef struct {<br />      long long number;<br />    } Small;<br />    <br />    typedef struct {<br />      int x;<br />      char* hello;<br />      Small sm;<br />    } Big;<br />    </pre></code></div><div style = "width:55%"><div style = "overflow: scroll;"><b>Generated Scala</b><div style = "max-height:400px"><pre><code class = "hljs language-scala">package libtest<br><br>import _root_.scala.scalanative.unsafe.*<br>import _root_.scala.scalanative.unsigned.*<br>import _root_.scala.scalanative.libc.*<br>import _root_.scala.scalanative.*<br><br>object structs:<br>  import _root_.libtest.structs.*<br><br>  opaque type Big = CStruct3[CInt, CString, Small]<br>  object Big:<br>    given _tag: Tag[Big] = Tag.materializeCStruct3Tag[CInt, CString, Small]<br>    def apply()(using Zone): Ptr[Big] = scala.scalanative.unsafe.alloc[Big](1)<br>    def apply(x : CInt, hello : CString, sm : Small)(using Zone): Ptr[Big] = <br>      val ____ptr = apply()<br>      (!____ptr).x = x<br>      (!____ptr).hello = hello<br>      (!____ptr).sm = sm<br>      ____ptr<br>    extension (struct: Big)<br>      def x : CInt = struct._1<br>      def x_=(value: CInt): Unit = !struct.at1 = value<br>      def hello : CString = struct._2<br>      def hello_=(value: CString): Unit = !struct.at2 = value<br>      def sm : Small = struct._3<br>      def sm_=(value: Small): Unit = !struct.at3 = value<br><br>  opaque type Small = CStruct1[CLongLong]<br>  object Small:<br>    given _tag: Tag[Small] = Tag.materializeCStruct1Tag[CLongLong]<br>    def apply()(using Zone): Ptr[Small] = scala.scalanative.unsafe.alloc[Small](1)<br>    def apply(number : CLongLong)(using Zone): Ptr[Small] = <br>      val ____ptr = apply()<br>      (!____ptr).number = number<br>      ____ptr<br>    extension (struct: Small)<br>      def number : CLongLong = struct._1<br>      def number_=(value: CLongLong): Unit = !struct.at1 = value<br><br>object types:<br>  export _root_.libtest.structs.*<br></code></pre></div></div></div></div>
<h3><a href="#you-can-disable-constructor-generation" id="you-can-disable-constructor-generation">You can disable constructor generation</a></h3>
<p>Some bindings (libnotify, gtk, nuklear) have such deep type hierarchies, that apply methods
on some structs trigger an exception during bytecode generation (when compiling the generated
code):</p>
<pre><code>java.lang.IllegalArgumentException: UTF8 string too large
</code></pre>
<p>To work around it, you can disable constructor generation by passing a comma-separated
list of struct names using the <code>--render.no-constructor</code> option in CLI, and <code>noConstructor</code>
parameter in the <code>Binding(...)</code> specification.</p>
<div style = "display:flex;width:100%; font-size:16px; justify-content: space-between;"><div style = "width: 40%; text-align: left"><b>C file</b><pre><code class = "hljs language-c"><br />      typedef struct {<br />        int x;<br />        char* hello;<br />      } Enabled;<br />      <br />      typedef struct {<br />        int x;<br />        char* hello;<br />      } Disabled;<br />      </pre></code></div><div style = "width:55%"><div style = "overflow: scroll;"><b>Generated Scala</b><div style = "max-height:400px"><pre><code class = "hljs language-scala">package libtest<br><br>import _root_.scala.scalanative.unsafe.*<br>import _root_.scala.scalanative.unsigned.*<br>import _root_.scala.scalanative.libc.*<br>import _root_.scala.scalanative.*<br><br>object structs:<br>  import _root_.libtest.structs.*<br><br>  opaque type Disabled = CStruct2[CInt, CString]<br>  object Disabled:<br>    given _tag: Tag[Disabled] = Tag.materializeCStruct2Tag[CInt, CString]<br>    def apply()(using Zone): Ptr[Disabled] = scala.scalanative.unsafe.alloc[Disabled](1)<br>    extension (struct: Disabled)<br>      def x : CInt = struct._1<br>      def x_=(value: CInt): Unit = !struct.at1 = value<br>      def hello : CString = struct._2<br>      def hello_=(value: CString): Unit = !struct.at2 = value<br><br>  opaque type Enabled = CStruct2[CInt, CString]<br>  object Enabled:<br>    given _tag: Tag[Enabled] = Tag.materializeCStruct2Tag[CInt, CString]<br>    def apply()(using Zone): Ptr[Enabled] = scala.scalanative.unsafe.alloc[Enabled](1)<br>    def apply(x : CInt, hello : CString)(using Zone): Ptr[Enabled] = <br>      val ____ptr = apply()<br>      (!____ptr).x = x<br>      (!____ptr).hello = hello<br>      ____ptr<br>    extension (struct: Enabled)<br>      def x : CInt = struct._1<br>      def x_=(value: CInt): Unit = !struct.at1 = value<br>      def hello : CString = struct._2<br>      def hello_=(value: CString): Unit = !struct.at2 = value<br><br>object types:<br>  export _root_.libtest.structs.*<br></code></pre></div></div></div></div>
<h2><a href="#unions-are-converted-to-opaque-types" id="unions-are-converted-to-opaque-types">Unions are converted to opaque types</a></h2>
<p>For a union with <code>N</code> members, <code>N</code> constructors will be generated,
along with getters and setters.</p>
<div style = "display:flex;width:100%; font-size:16px; justify-content: space-between;"><div style = "width: 40%; text-align: left"><b>C file</b><pre><code class = "hljs language-c"><br />        typedef struct {<br />          long long number;<br />        } Small;<br />        <br />        typedef union {<br />          int x;<br />          char* hello;<br />          Small sm;<br />        } Big;<br />        </pre></code></div><div style = "width:55%"><div style = "overflow: scroll;"><b>Generated Scala</b><div style = "max-height:400px"><pre><code class = "hljs language-scala">package libtest<br><br>import _root_.scala.scalanative.unsafe.*<br>import _root_.scala.scalanative.unsigned.*<br>import _root_.scala.scalanative.libc.*<br>import _root_.scala.scalanative.*<br><br>object structs:<br>  import _root_.libtest.structs.*<br>  import _root_.libtest.unions.*<br><br>  opaque type Small = CStruct1[CLongLong]<br>  object Small:<br>    given _tag: Tag[Small] = Tag.materializeCStruct1Tag[CLongLong]<br>    def apply()(using Zone): Ptr[Small] = scala.scalanative.unsafe.alloc[Small](1)<br>    def apply(number : CLongLong)(using Zone): Ptr[Small] = <br>      val ____ptr = apply()<br>      (!____ptr).number = number<br>      ____ptr<br>    extension (struct: Small)<br>      def number : CLongLong = struct._1<br>      def number_=(value: CLongLong): Unit = !struct.at1 = value<br><br>object unions:<br>  import _root_.libtest.structs.*<br>  import _root_.libtest.unions.*<br><br>  opaque type Big = CArray[Byte, Nat._8]<br>  object Big:<br>    given _tag: Tag[Big] = Tag.CArray[CChar, Nat._8](Tag.Byte, Tag.Nat8)<br>    def apply()(using Zone): Ptr[Big] = <br>      val ___ptr = alloc[Big](1)<br>      ___ptr<br>    @scala.annotation.targetName("apply_x")<br>    def apply(x: CInt)(using Zone): Ptr[Big] =<br>      val ___ptr = alloc[Big](1)<br>      val un = !___ptr<br>      un.at(0).asInstanceOf[Ptr[CInt]].update(0, x)<br>      ___ptr<br>    @scala.annotation.targetName("apply_hello")<br>    def apply(hello: CString)(using Zone): Ptr[Big] =<br>      val ___ptr = alloc[Big](1)<br>      val un = !___ptr<br>      un.at(0).asInstanceOf[Ptr[CString]].update(0, hello)<br>      ___ptr<br>    @scala.annotation.targetName("apply_sm")<br>    def apply(sm: Small)(using Zone): Ptr[Big] =<br>      val ___ptr = alloc[Big](1)<br>      val un = !___ptr<br>      un.at(0).asInstanceOf[Ptr[Small]].update(0, sm)<br>      ___ptr<br>    extension (struct: Big)<br>      def x : CInt = !struct.at(0).asInstanceOf[Ptr[CInt]]<br>      def x_=(value: CInt): Unit = !struct.at(0).asInstanceOf[Ptr[CInt]] = value<br>      def hello : CString = !struct.at(0).asInstanceOf[Ptr[CString]]<br>      def hello_=(value: CString): Unit = !struct.at(0).asInstanceOf[Ptr[CString]] = value<br>      def sm : Small = !struct.at(0).asInstanceOf[Ptr[Small]]<br>      def sm_=(value: Small): Unit = !struct.at(0).asInstanceOf[Ptr[Small]] = value<br><br>object types:<br>  export _root_.libtest.structs.*<br>  export _root_.libtest.unions.*<br></code></pre></div></div></div></div>
<h3><a href="#simple-functions-are-converted-to-direct-extern-functions" id="simple-functions-are-converted-to-direct-extern-functions">Simple functions are converted to direct <code>@extern</code> functions</a></h3>
<p>Where &quot;Simple&quot; means &quot;not passing naked <code>structs</code>&quot;, because Scala Native cannot handle that (passing by pointer is okay)</p>
<div style = "display:flex;width:100%; font-size:16px; justify-content: space-between;"><div style = "width: 40%; text-align: left"><b>C file</b><pre><code class = "hljs language-c"><br />          typedef struct {<br />            long long number;<br />          } Small;<br />          <br />          long simple(int x, char *y);<br />          Small* with_pointers(Small *x, int y);<br />          </pre></code></div><div style = "width:55%"><div style = "overflow: scroll;"><b>Generated Scala</b><div style = "max-height:400px"><pre><code class = "hljs language-scala">package libtest<br><br>import _root_.scala.scalanative.unsafe.*<br>import _root_.scala.scalanative.unsigned.*<br>import _root_.scala.scalanative.libc.*<br>import _root_.scala.scalanative.*<br><br>object structs:<br>  import _root_.libtest.structs.*<br><br>  opaque type Small = CStruct1[CLongLong]<br>  object Small:<br>    given _tag: Tag[Small] = Tag.materializeCStruct1Tag[CLongLong]<br>    def apply()(using Zone): Ptr[Small] = scala.scalanative.unsafe.alloc[Small](1)<br>    def apply(number : CLongLong)(using Zone): Ptr[Small] = <br>      val ____ptr = apply()<br>      (!____ptr).number = number<br>      ____ptr<br>    extension (struct: Small)<br>      def number : CLongLong = struct._1<br>      def number_=(value: CLongLong): Unit = !struct.at1 = value<br><br><br>@extern<br>private[libtest] object extern_functions:<br>  import _root_.libtest.structs.*<br><br>  def simple(x : CInt, y : CString): CLongInt = extern<br><br>  def with_pointers(x : Ptr[Small], y : CInt): Ptr[Small] = extern<br><br><br>object functions:<br>  import _root_.libtest.structs.*<br><br>  import extern_functions.*<br>  export extern_functions.*<br><br>object types:<br>  export _root_.libtest.structs.*<br></code></pre></div></div></div></div>
<h2><a href="#problematic-functions-generate-c-forwarders" id="problematic-functions-generate-c-forwarders">Problematic functions generate C forwarders</a></h2>
<p>Where &quot;Problematic&quot; means having a struct as one of its arguments or return type.
In this case we generate several variations of public Scala functions,
but they all delegate to an external C function which takes its arguments as <strong>pointers</strong>, and (optionally) returns its value in a provided heap-allocated location.</p>
<div style = "display:flex;width:100%; font-size:16px; justify-content: space-between;"><div style = "width: 40%; text-align: left"><b>C file</b><pre><code class = "hljs language-c"><br />            typedef struct {<br />              long long number;<br />            } Small;<br />            <br />            void bad_arguments(Small n, Small n2);<br />            Small bad_return_type();<br />            </pre></code></div><div style = "width:55%"><div style = "overflow: scroll;"><b>Generated Scala</b><div style = "max-height:400px"><pre><code class = "hljs language-scala">package libtest<br><br>import _root_.scala.scalanative.unsafe.*<br>import _root_.scala.scalanative.unsigned.*<br>import _root_.scala.scalanative.libc.*<br>import _root_.scala.scalanative.*<br><br>object structs:<br>  import _root_.libtest.structs.*<br><br>  opaque type Small = CStruct1[CLongLong]<br>  object Small:<br>    given _tag: Tag[Small] = Tag.materializeCStruct1Tag[CLongLong]<br>    def apply()(using Zone): Ptr[Small] = scala.scalanative.unsafe.alloc[Small](1)<br>    def apply(number : CLongLong)(using Zone): Ptr[Small] = <br>      val ____ptr = apply()<br>      (!____ptr).number = number<br>      ____ptr<br>    extension (struct: Small)<br>      def number : CLongLong = struct._1<br>      def number_=(value: CLongLong): Unit = !struct.at1 = value<br><br><br>@extern<br>private[libtest] object extern_functions:<br>  import _root_.libtest.structs.*<br><br>  private[libtest] def __sn_wrap_libtest_bad_arguments(n : Ptr[Small], n2 : Ptr[Small]): Unit = extern<br><br>  private[libtest] def __sn_wrap_libtest_bad_return_type(__return : Ptr[Small]): Unit = extern<br><br><br>object functions:<br>  import _root_.libtest.structs.*<br><br>  import extern_functions.*<br>  export extern_functions.*<br><br>  def bad_arguments(n : Ptr[Small], n2 : Ptr[Small]): Unit = <br>    __sn_wrap_libtest_bad_arguments(n, n2)<br><br>  def bad_arguments(n : Small, n2 : Small)(using Zone): Unit = <br>    val __ptr_0: Ptr[Small] = alloc[Small](2)<br>    !(__ptr_0 + 0) = n<br>    !(__ptr_0 + 1) = n2<br>    __sn_wrap_libtest_bad_arguments((__ptr_0 + 0), (__ptr_0 + 1))<br><br>  def bad_return_type()(__return : Ptr[Small]): Unit = <br>    __sn_wrap_libtest_bad_return_type(__return)<br><br>  def bad_return_type()(using Zone): Small = <br>    val __ptr_0: Ptr[Small] = alloc[Small](1)<br>    __sn_wrap_libtest_bad_return_type((__ptr_0 + 0))<br>    !(__ptr_0 + 0)<br><br>object types:<br>  export _root_.libtest.structs.*<br></code></pre></div></div><div style = "overflow: scroll;"><b>Generated C</b><div style = "max-height:400px"><pre><code class = "hljs">&#35;include &lt;string.h&gt;<br><br>void __sn_wrap_libtest_bad_arguments(Small *n, Small *n2) {<br> bad_arguments(*n, *n2);<br>};<br><br><br>void __sn_wrap_libtest_bad_return_type(Small *____return) {<br>  Small ____ret = bad_return_type();<br>  memcpy(____return, &____ret, sizeof(Small));<br>}<br><br><br></code></pre></div></div></div></div>
<h2><a href="#enums-are-generated-for-specific-c-type" id="enums-are-generated-for-specific-c-type">Enums are generated for specific C type</a></h2>
<p>Whatever type clang reports for a particular enum - that's the type that will be
used for the enum.</p>
<p>This is important, as on Windows enums are <code>int</code> by default, whereas on Linux and OS X they are <code>unsigned int</code> (if there's no negative elements).</p>
<p>This documentation is built on Linux.</p>
<div style = "display:flex;width:100%; font-size:16px; justify-content: space-between;"><div style = "width: 40%; text-align: left"><b>C file</b><pre><code class = "hljs language-c"><br />              typedef enum {<br />                U_X = 1,<br />                U_Y = 4,<br />                U_Z = 228<br />              } MyUnsigned;<br />              <br />              typedef enum {<br />                X = -1,<br />                Y = 4,<br />                Z = 228<br />              } MySigned;<br />              </pre></code></div><div style = "width:55%"><div style = "overflow: scroll;"><b>Generated Scala</b><div style = "max-height:400px"><pre><code class = "hljs language-scala">package libtest<br><br>import _root_.scala.scalanative.unsafe.*<br>import _root_.scala.scalanative.unsigned.*<br>import _root_.scala.scalanative.libc.*<br>import _root_.scala.scalanative.*<br><br>object predef:<br>  private[libtest] trait CEnum[T](using eq: T =:= Int):<br>    given Tag[T] = Tag.Int.asInstanceOf[Tag[T]]<br>    extension (inline t: T) <br>      inline def int: CInt = eq.apply(t)<br>      inline def value: CInt = eq.apply(t)<br>  private[libtest] trait CEnumU[T](using eq: T =:= UInt):<br>    given Tag[T] = Tag.UInt.asInstanceOf[Tag[T]]<br>    extension (inline t: T)<br>     inline def int: CInt = eq.apply(t).toInt<br>     inline def uint: CUnsignedInt = eq.apply(t)<br>     inline def value: CUnsignedInt = eq.apply(t)<br><br><br>object enumerations:<br>  import predef.*<br>  opaque type MySigned = CInt<br>  object MySigned extends CEnum[MySigned]:<br>    given _tag: Tag[MySigned] = Tag.Int<br>    inline def define(inline a: CInt): MySigned = a<br>    val X = define(-1)<br>    val Y = define(4)<br>    val Z = define(228)<br>    inline def getName(inline value: MySigned): Option[String] =<br>      value match<br>        case X => Some("X")<br>        case Y => Some("Y")<br>        case Z => Some("Z")<br>        case _ => None<br>    extension (a: MySigned)<br>      inline def &(b: MySigned): MySigned = a & b<br>      inline def |(b: MySigned): MySigned = a | b<br>      inline def is(b: MySigned): Boolean = (a & b) == b<br><br>  opaque type MyUnsigned = CUnsignedInt<br>  object MyUnsigned extends CEnumU[MyUnsigned]:<br>    given _tag: Tag[MyUnsigned] = Tag.UInt<br>    inline def define(inline a: Long): MyUnsigned = a.toUInt<br>    val U_X = define(1)<br>    val U_Y = define(4)<br>    val U_Z = define(228)<br>    inline def getName(inline value: MyUnsigned): Option[String] =<br>      value match<br>        case U_X => Some("U_X")<br>        case U_Y => Some("U_Y")<br>        case U_Z => Some("U_Z")<br>        case _ => None<br>    extension (a: MyUnsigned)<br>      inline def &(b: MyUnsigned): MyUnsigned = a & b<br>      inline def |(b: MyUnsigned): MyUnsigned = a | b<br>      inline def is(b: MyUnsigned): Boolean = (a & b) == b<br><br>object types:<br>  export _root_.libtest.enumerations.*<br></code></pre></div></div></div></div>
<h2><a href="#function-pointers-are-defined-as-opaque-types" id="function-pointers-are-defined-as-opaque-types">Function pointers are defined as opaque types</a></h2>
<p>The inlining in <code>apply</code> method is important - it's a restricting of Scala Native
that the function must be statically known.</p>
<div style = "display:flex;width:100%; font-size:16px; justify-content: space-between;"><div style = "width: 40%; text-align: left"><b>C file</b><pre><code class = "hljs language-c"><br />                typedef void* Cursor;<br />                typedef int (*Visitor)(Cursor*);<br />                </pre></code></div><div style = "width:55%"><div style = "overflow: scroll;"><b>Generated Scala</b><div style = "max-height:400px"><pre><code class = "hljs language-scala">package libtest<br><br>import _root_.scala.scalanative.unsafe.*<br>import _root_.scala.scalanative.unsigned.*<br>import _root_.scala.scalanative.libc.*<br>import _root_.scala.scalanative.*<br><br>object aliases:<br>  import _root_.libtest.aliases.*<br><br>  opaque type Cursor = Ptr[Byte]<br>  object Cursor: <br>    given _tag: Tag[Cursor] = Tag.Ptr(Tag.Byte)<br>    inline def apply(inline o: Ptr[Byte]): Cursor = o<br>    extension (v: Cursor)<br>      inline def value: Ptr[Byte] = v<br><br>  opaque type Visitor = CFuncPtr1[Ptr[Cursor], CInt]<br>  object Visitor: <br>    given _tag: Tag[Visitor] = Tag.materializeCFuncPtr1[Ptr[Cursor], CInt]<br>    inline def apply(inline o: CFuncPtr1[Ptr[Cursor], CInt]): Visitor = o<br>    extension (v: Visitor)<br>      inline def value: CFuncPtr1[Ptr[Cursor], CInt] = v<br><br>object types:<br>  export _root_.libtest.aliases.*<br></code></pre></div></div></div></div>
<h2><a href="#recursive-structs-are-rewritten-with-opaque-pointers" id="recursive-structs-are-rewritten-with-opaque-pointers">Recursive structs are rewritten with opaque pointers</a></h2>
<p>This is invisible to the user, so doesn't impact the experience, but
can complicate reading the code.</p>
<p>Scala cannot have recursive type aliases.</p>
<div style = "display:flex;width:100%; font-size:16px; justify-content: space-between;"><div style = "width: 40%; text-align: left"><b>C file</b><pre><code class = "hljs language-c"><br />                  typedef struct Arr;<br />                  <br />                  typedef struct {<br />                    struct Arr* nested;<br />                  } Arr;<br />                  </pre></code></div><div style = "width:55%"><div style = "overflow: scroll;"><b>Generated Scala</b><div style = "max-height:400px"><pre><code class = "hljs language-scala">package libtest<br><br>import _root_.scala.scalanative.unsafe.*<br>import _root_.scala.scalanative.unsigned.*<br>import _root_.scala.scalanative.libc.*<br>import _root_.scala.scalanative.*<br><br>object structs:<br>  import _root_.libtest.structs.*<br><br>  opaque type Arr = CStruct1[Ptr[Byte]]<br>  object Arr:<br>    given _tag: Tag[Arr] = Tag.materializeCStruct1Tag[Ptr[Byte]]<br>    def apply()(using Zone): Ptr[Arr] = scala.scalanative.unsafe.alloc[Arr](1)<br>    def apply(nested : Ptr[Arr])(using Zone): Ptr[Arr] = <br>      val ____ptr = apply()<br>      (!____ptr).nested = nested<br>      ____ptr<br>    extension (struct: Arr)<br>      def nested : Ptr[Arr] = struct._1.asInstanceOf[Ptr[Arr]]<br>      def nested_=(value: Ptr[Arr]): Unit = !struct.at1 = value.asInstanceOf[Ptr[Byte]]<br><br>object types:<br>  export _root_.libtest.structs.*<br></code></pre></div></div></div></div>
<h2><a href="#global-enums-are-rendered-as-constants" id="global-enums-are-rendered-as-constants">Global enums are rendered as constants</a></h2>
<div style = "display:flex;width:100%; font-size:16px; justify-content: space-between;"><div style = "width: 40%; text-align: left"><b>C file</b><pre><code class = "hljs language-c"><br />                    enum {<br />                      HELLO = 25,<br />                      BYEBYE = 11<br />                    };<br />                    <br />                    enum {<br />                      HOW=-1,<br />                      DOESTHIS=-2,<br />                      WORK=0<br />                    };<br />                    </pre></code></div><div style = "width:55%"><div style = "overflow: scroll;"><b>Generated Scala</b><div style = "max-height:400px"><pre><code class = "hljs language-scala">package libtest<br><br>import _root_.scala.scalanative.unsafe.*<br>import _root_.scala.scalanative.unsigned.*<br>import _root_.scala.scalanative.libc.*<br>import _root_.scala.scalanative.*<br><br>object constants:<br>  val HELLO: CUnsignedInt = 25.toUInt<br>  val BYEBYE: CUnsignedInt = 11.toUInt<br>  <br>  val HOW: CInt = -1<br>  val DOESTHIS: CInt = -2<br>  val WORK: CInt = 0<br>  <br></code></pre></div></div></div></div>
</div></div><footer>© 2021-2023 Anton Sviridov</footer><script src="https://www.googletagmanager.com/gtag/js?id=G-2V7BY56Z37"></script><script> window.dataLayer = window.dataLayer || [];
              function gtag(){window.dataLayer.push(arguments);}
              gtag('js', new Date());

              gtag('config', 'G-2V7BY56Z37');</script></body></html>